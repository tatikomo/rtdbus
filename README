Макет комплекса обмена сообщениями и доступа к БДРВ.

Используемые продукты и технологии
1. zeromq 3.2
2. eXtremeDB 3.5
3. google protobuf 2.4.1
4. google logging 1.6.0

ОТЛАДКА
--------------------------------------------------------------------------------
Для корректной работы valgrind при обработке программ с включенной библиотекой 
ZMQ необходимо использовать следующую командную строку:
valgrind --tool=memcheck --leak-check=full --suppressions=valgrind.supp someprog

Перед компиляцией создать ссылки для zmq.h zmq.hpp из cppzmq/include в zeromq/src.

Настройка отладочного вывода 
--------------------------------------------------------------------------------
Используется библиотека glog от GOOGLE, устанавливается в /usr/local
Использование GLOG
If the Google gflags library isn't installed, you set flags via environment variables, prefixing the flag name with "GLOG_", e.g.
   GLOG_logtostderr=1 ./your_application
The following flags are most commonly used:

logtostderr (bool, default=false)
Log messages to stderr instead of logfiles.
Note: you can set binary flags to true by specifying 1, true, or yes (case insensitive). Also, you can set binary flags to false by specifying 0, false, or no (again, case insensitive).
stderrthreshold (int, default=2, which is ERROR)
Copy log messages at or above this level to stderr in addition to logfiles. The numbers of severity levels INFO, WARNING, ERROR, and FATAL are 0, 1, 2, and 3, respectively.
minloglevel (int, default=0, which is INFO)
Log messages at or above this level. Again, the numbers of severity levels INFO, WARNING, ERROR, and FATAL are 0, 1, 2, and 3, respectively.
log_dir (string, default="")
If specified, logfiles are written into this directory instead of the default logging directory.
v (int, default=0)
Show all VLOG(m) messages for m less or equal the value of this flag. Overridable by --vmodule. See the section about verbose logging for more detail.
vmodule (string, default="")
Per-module verbose level. The argument has to contain a comma-separated list of <module name>=<log level>. <module name> is a glob pattern (e.g., gfs* for all modules whose name starts with "gfs"), matched against the filename base (that is, name ignoring .cc/.h./-inl.h). <log level> overrides any value given by --v. See also the section about verbose logging.
There are some other flags defined in logging.cc. Please grep the source code for "DEFINE_" to see a complete list of all flags.

Используется ctags (exuberant-ctags) для создания библиотеки перекрестных ссылок в исходных текстах
Файл tags создается командой:
ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .

Используется cppcheck для статической проверки исходных текстов:
cppcheck . --force -Icmake -Imdp -I../zeromq-3.2.2/src -Imsg -Itools -Idatabase -I../eXtremeDB_5_fusion_eval/include -I../glog-0.3.2/src -I../gtest-1.6.0/include -Iclient -Iworker

Хронология проблем:
--------------------------------------------------------------------------------
04.03.2013 = Решено
Worker не получает сообщения от Брокера. После нескольких безответных (с точки зрения worker-а) попыток передачи HEARTBEAT сервис перезапускается. Эта ситуация диагностируется Брокером успешно.

13.03.2013 
Проблема от 04.03.2013 решена. Исправлена ошибка в поле сообщения, используемая протоколом ZMQ в качестве адресата.

14.03.2013
Бинарная совместимость с протоколом Majordomo 0.2.0 

15.03.2013
Опробована работа под Solaris 9:
- всей связки целиком
- брокер на linux, служба в solaris
Обнаружено постепенно увеличивающееся с каждой итерацией количество сообщений HEARTBEAT, 
посылаемых службе единовременно. 

27.08.2013
У библиотеки ZMQ (как минимум в 3.2) есть потенциальная проблема с сокетами ROUTER:
если удаленная сторона не отвечает на запрос, происходит утечка памяти. 
An unavoidable memory leak in ROUTER sockets when there is pending data for clients who will never return.
Ссылка на статью: http://gonitro.io, https://github.com/bumptech/nitro

11.09.2013 = Решено
Чтение содержимого сериализованных полей Сообщения из базы данных завершается без ошибок, но данные не соответствуют исходным. Была проблема в некорректном указании длины строки, читаемой из БД, для последующей десериализации.

13.09.2013 = Решено
Нарушение уникальности ключа PK_expire_for_service у Letter приводило к невозможности иметь более одного экземпляра
сообщения в БД с одинаковыми секундными отметками времени. Однако у одной Службы может быть несколько одновременно
поступивших изменений, пришлось убрать тег unique с этого индекса.

TODO
--------------------------------------------------------------------------------
Требование:
Проверить возможность использования std::string в качестве полезной нагрузки.
Можно ли хранить protobuf в std::string? Стоит перейти на zframe вместо string?
Ответ:
Тип данных string пригоден для хранения UTF-8 и бинарных данных. Локализованные строки нормально хранятся и
читаются из Базы данных.

Требование:
Рассмотреть возможность внедрения поддержки UNICODE, используя библиотеку ICU.

Версия 3.5 eXtremeDB не поддерживает неуникальные таблицы хешей. Множество одинаковых 
значений могут содержать только деревья. Хеши версии 4.1 и выше могут содержать 
неуникальные ключи. Так как текущая версия БД равна 3.5, но впоследствии планируется 
переход на 4.1, можно использовать хеши. Это повлечет ограничение - у каждого Сервиса 
может быть только один Обработчик. После перехода на 4.1 это ограничение можно снять. 
Или в 3.5 использовать деревья, а после миграции на 4.1 перейти на хеши, меньше 
накладных расходов.

Требование:
PushWorker() для существующего Обработчика обновит его поле состояния, оставив все остальное 
без изменений. Возможно требуется очистка полей этого Экземпляра - удаление связанных 
Сообщений и т.п.

Требование:
Значения интервалов HEARTBEAT у Брокера и Обработчиков задаются в разных местах. Нужно объединить.
Решение:
Период HEARTBEAT задается в config.h.

Требование:
Проверить условия получения идентификатора отправителя "mmi.*", это приводит к удалению Обработчика.
Решение:
Это название Службы, к которой адресовано служебное сообщение.

Рассмотреть необходимость присутствия в заголовке строковых полей "Отправитель" и "Адресат". Эта информация
дублирует систему идентификаторов (IDENTITY), и увеличивает размер заголовка.

Выбирать из очереди сообщений для передачи их свободному Обработчику следует те экземпляры, 
которые ждут своей очереди более остальных.

Проверить, верно ли что: возврат из mdcli->recv() с нулевым сообщением означает получение ответа 
на сообщение, просроченного более чем на 2 секунды? К примеру, запрос был послан 2.5 секунды назад, 
и только что получен ответ, хотя сокет DEALER его уже не ждал?

Требование: Минимизировать количество ходящих сообщений HEARTBEAT. Если от процесса было сообщение не далее чем 
величина интервала HEARTBEAT, не посылать ему этот запрос. В файле mdp_broker.cpp, функция worker_waiting(), 
строка 685, не вызывается worker_send(HEARTBEAT...) согласно zguide/C/mdbroker.c
Решение:
Не посылать HEARTBEAT-сообщение для процессов, интенсивно обменивающихся с Брокером. Коммит b4b92b3.

Требование:
Ввести в Брокере фоновую нить, проверяющую наличие устаревших Обработчиков и Сообщений.
Если Обработчик устарел, и не имеет связанного сообщения, удалить его из БД.
Если Сообщение устарело, передать его на исполнение другому обработчику или ответить Клиенту отказом.

Удаленные сетевые и локальные репозитории
На gev-book добавлен сетевой репозиторий gev@gev-itg:/var/git/rtdbus.git
На gev-itg добавлен локальный промежуточный репозиторий integration
  gev@gev-itg:/var/git/rtdbus.git$ git remote -v
    origin  /home/gev/ITG/sandbox/rtdbus (fetch)
    origin  /home/gev/ITG/sandbox/rtdbus (push)
  gev@gev-book ~/ITG/rtdbus $ git remote -v
    origin  gev@gev-itg:/var/git/rtdbus.git (fetch)
    origin  gev@gev-itg:/var/git/rtdbus.git (push)
  gev@gev-itg:~/ITG/sandbox/rtdbus$ git remote -v
    integration   /var/git/rtdbus.git (fetch)
    integration   /var/git/rtdbus.git (push)
    origin    git@bitbucket.org:gev76/rtdbus.git (fetch)
    origin    git@bitbucket.org:gev76/rtdbus.git (push)

