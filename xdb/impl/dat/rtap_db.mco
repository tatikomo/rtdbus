/* 
 * Instance of RTAP database description
 *
 * AUTHOR:     GEV
 * START DATE: 17/03/2009
 */

#define int1        signed<1>
#define int2        signed<2>
#define int4        signed<4>
#define int8        signed<8>
#define uint8       unsigned<8>
#define uint4       unsigned<4>
#define uint2       unsigned<2>
#define uint1       unsigned<1>
#define i_objclass  unsigned<1>
#define logical     unsigned<1>
#define s_code      char<8>
#define s_label     char<80>
#define s_formula   char<40>
#define s_univname  char<32>
#define s_dispatch  char<20>
#define s_valabel   char<12>
#define s_unity     char<12>
#define s_shortlabel    char<16>
#define s_attname       char<16>
#define s_statelabel    char<32>

#define MAX_POINTS_QUANTITY  10000
#define MAX_ALARMS_QUANTITY   1000
/* max history table depth for all points */
#define MAX_HISTORY_QUANTITY 10000
/* max history table depth for single analog instance */
#define MAX_HIST_A_QUANTITY_PER_POINT 100
/* max history table depth for single discrete instance */
#define MAX_HIST_D_QUANTITY_PER_POINT 100

declare database  rtap_db;
/*struct Id {
  uint8 id;
};
declare oid Id[10000];*/

enum objclass_t {
    TS  = 0,
    TM  = 1,
    TR  = 2,
    TSA = 3,
    TSC = 4,
    TC  = 5,
    AL  = 6,
    ICS = 7,
    ICM = 8,
    PIPE    = 11,
    PIPELINE = 15,
    TL  = 16,
    VA  = 19,
    SC  = 20,
    ATC = 21,
    GRC  = 22,
    SV   = 23,
    SDG  = 24,
    RGA  = 25,
    SSDG = 26,
    BRG  = 27,
    SCP = 28,
    STG  = 29,
    DIR  = 30,
    DIPL = 31,
    METLINE  = 32,
    ESDG = 33,
    SVLINE   = 34,
    SCPLINE  = 35,
    TLLINE   = 36,
    INVT = 37,
    AUX1 = 38,
    AUX2 = 39,
    SITE = 45,
    SA   = 50,
    //HIST = 53,
    FIXEDPOINT   = 79,
    HIST = 80
};

/* ===================================================================== */
struct timestamp {
  uint4 sec;
  uint4 nsec;
};

/* ===================================================================== */
/* Linkage table between 'OBJCLASS' and symbolic class name */
class Link_OBJCLASS_CODE
{
  s_code        objectCode;        /* class name (ex. "TM", "TS", "ATC", "SA",... */
  objclass_t    OBJCLASS;          /* class ident */
  hash <objectCode> codeHash[100]; /* get objclass by code */
  unique tree <OBJCLASS> PK_by_id; /* search entry by numeric objclass */
};

/* ===================================================================== */
/* Linkage table between elementary data type and CODE' */
class Link_SIMPLE_TYPE
{
  s_shortlabel  dataType;          /* (ex. "LOGICAL", "BYTES256", "TIME_OF_DAY",... */
  uint1         dataID;            /* data ident */
  hash <dataType> typeHash[100];   /* search entry by its type */
  unique tree <dataID> PK_by_id;   /* search entry by numeric datatype */
};

/* ===================================================================== */
/* Linkage table between unity category and Infotype' instances */
class Link_UNITY_ID
{
  s_unity       UNITY;
  uint2         unityID;
  hash <UNITY>  unityHash[100];    /* max 100 different unities */
  unique tree <unityID> PK_by_id;  /* get unity instance by ID */
};

/* ===================================================================== */
/* ALARM table for analog and discrete information instances */
class Alarm
{
  autoid[MAX_ALARMS_QUANTITY];
  /* reference to Point instance */
  autoid_t      point_ref;

  timestamp    ALARMBEGIN;
  timestamp    ALARMBEGINACK;
  timestamp    ALARMENDACK;
  timestamp    ALARMSYNTH;

  /* Index by point reference */
  unique tree <point_ref> PK_by_id;
};

/* ===================================================================== */
/* Elementary historical data for analog information */
struct A_HIST_ITEM
{
  timestamp    mark;
  double        value;
};

/* Elementary historical data for discrete information */
struct D_HIST_ITEM
{
  timestamp    mark;
  uint8         value;
};

enum HistoryState {
  ENABLE, SUSPEND
};

/* HISTORY table for calculating analog historical data */
class A_HIST
{
  autoid[MAX_HISTORY_QUANTITY];
  HistoryState  STATE = SUSPEND; /* state may be active or suspended */
  vector <A_HIST_ITEM> items;  /* MAX_HIST_A_QUANTITY_PER_POINT */
  autoid_t  point_ref;
  unique tree <point_ref> SK_by_point; /* point to history relationship is '1-to-1' */
};

/* HISTORY table for calculating analog historical data */
class D_HIST
{
  autoid[MAX_HISTORY_QUANTITY];
  HistoryState  STATE = SUSPEND; /* */
  vector <D_HIST_ITEM> items;  /* MAX_HIST_D_QUANTITY_PER_POINT */
  autoid_t  point_ref;
  unique tree <point_ref> SK_by_point; /* point to history relationship is '1-to-1' */
};

/* ===================================================================== */
/* Common part for discrete-state objects */
struct DiscreteInfoType
{
  uint8         VAL;         /* from boolean to UINT64 (determined by simpleType) */
  uint8         VALACQ;      /* from source */
  uint8         VALMANUAL;   /* manual input */
  s_valabel     VAL_LABEL;   /* .VAL designation */
};

/* ===================================================================== */
/* Common part for analog-state objects */
struct AnalogInfoType
{
  double        VAL;
  double        VALACQ;
  double        VALMANUAL;
};

/* ===================================================================== */
/* POINT */
class Point
{
  /* Point autoincremental identifier */
  autoid[MAX_POINTS_QUANTITY];
  
  /* Point common STATIC part */
  s_univname    UNIVNAME;
  objclass_t    OBJCLASS;    /* class id */
  /* short human-readable designation (TODO: store in external DB) */
  s_shortlabel  SHORTLABEL;
  /* full human-readable designation (TODO: migrating to external DB) */
  /* s_label       longLabel;*/
  uint2         UNITY_ID;    /* link to unity category */
  uint1         DE_TYPE;     /* type of data [ex. LOGICAL or BYTES256] */ 
  s_formula     CALCULATING_ENGINE; /* calculation engine for realtime value correction */
  autoid_t      linkSA;      /* reference to SA object */
  /* Reference to point-specific attributes */
  autoid_t      passport_ref;
  /* Reference to ALARM table */
  autoid_t      alarm_ref;
  /* Reference to HISTORY table for analog (A_HIST_*/
  autoid_t      hist_ref;

  /* Point common DYNAMIC part */
  /* Runtime values modification support */
  uint1         VALIDCHANGE; /* CE trugger */
  timestamp     DATEHOURM;   /* last modification time */
  uint1         VALIDITY;    /* VALID|INVALID|MANUAL|... */
  uint1         VALIDITY_ACQ;/* */

  /* Optional analog of discrete part */
  optional  AnalogInfoType   ai;
  optional  DiscreteInfoType di;
  
  /* Indexes */
  unique tree <passport_ref> SK_by_passport; /* point to passport relationship is '1-to-1' */
  /* locating point instance by univname */
  hash <UNIVNAME> SK_by_univname[MAX_POINTS_QUANTITY];
};

/* ===================================================================== */
/* Passports contains list of attributes specific to this kind of point  */
/* ===================================================================== */
class TS_passport /* TS 00 */
{
  autoid[MAX_POINTS_QUANTITY]; /* TODO: redefine the limit */
  logical       INHIBLOCAL;
};


/* ===================================================================== */
/* Passports contains list of attributes specific to this kind of point  */
/* ===================================================================== */
class TM_passport   /* TM 01 */
{
  autoid[MAX_POINTS_QUANTITY]; /* TODO: redefine the limit */
  double MNVALPHY;
  double MXVALPHY;
  autoid_t      LINK_HIST;
  /* class 'Point' will reference this by autogenerated index */
};


/* ===================================================================== */
/* Passports contains list of attributes specific to this kind of point  */
/* ===================================================================== */
// Запись о поданных командах
struct VA_command
{
  timestamp     mark;
  uint2         ref_cmd;
  s_dispatch    dispatcher;
  uint1         state_code;
  s_statelabel  state_text;
};

// Запись об обслуживании Крана
struct VA_maintenance
{
  timestamp     mark;
  uint2         ref_cmd;
  s_dispatch    dispatcher;
  uint1         state_code;
  s_statelabel  state_text;
};

// Запись о переставке Крана - кто, когда, новое положение, код завершения команды
struct VA_operating
{
  timestamp     mark;
  uint2         value;
  uint2         valid;
  s_dispatch    dispatcher;
};

class VA_passport   /* VA 19 */
{
 autoid[MAX_POINTS_QUANTITY];   /* TODO: redefine the limit */
 logical    LOCALFLAG;
 logical    STATUS;
 logical    INHIB;
 logical    INHIBLOCAL;
 logical    ALINHIB;
 logical    CONFREMOTECMD;
 logical    FLGREMOTECMD;
 logical    REMOTECONTROL;
 logical    FLGMAINTENANCE;
 s_dispatch NAMEMAINTENANCE;
 uint1      TSSYNTHETICAL;
 vector     <VA_command>     commands;
 vector     <VA_maintenance> maintenance;
 vector     <VA_operating>   operating;
};
