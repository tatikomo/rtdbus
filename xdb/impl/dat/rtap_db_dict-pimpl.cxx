// Not copyrighted - public domain.
//
// This sample parser implementation was generated by CodeSynthesis XSD,
// an XML Schema to C++ data binding compiler. You may use it in your
// programs without any restrictions.
//

#include "rtap_db_dict-pimpl.hxx"
#include "rtap_db_dict.hxx"

#include <iostream>

// 
// NB Допустимый диапазон всех параметров задан в rtap_db_dict.xsd
//
namespace rtap_db_dict
{

  static UNITY_LABEL_pimpl* unity_label_item = NULL;
  static VAL_LABEL_pimpl*   value_label_item = NULL;
  static INFO_TYPES_pimpl*  infotype_item = NULL;

  // ObjClassEntry_pimpl
  //

  void ObjClassEntry_pimpl::
  pre ()
  {
    m_value = UNUSED;
  }

  // [ TS(0)..HIST(80) ]
  rtap_db_dict::ObjClass_t ObjClassEntry_pimpl::
  post_ObjClassEntry ()
  {
    long long v (post_integer ());

    if ((TS <= v) && (v <= HIST))
      m_value = static_cast<rtap_db_dict::ObjClass_t>(v);
    
    return m_value;
  }

  // ValueEntry_pimpl
  //

  void ValueEntry_pimpl::
  pre ()
  {
    m_value = 0;
  }

  rtap_db_dict::id_t ValueEntry_pimpl::
  post_ValueEntry ()
  {
    long long v (post_integer ());

    if ((0 <= v) && (v <= VALUE_ENTRY_MAX))
      m_value = static_cast<rtap_db_dict::id_t>(v);

    return m_value;
  }

  // ValueLabelEntry_pimpl
  //

  void ValueLabelEntry_pimpl::
  pre ()
  {
  }

  rtap_db_dict::Label_t& ValueLabelEntry_pimpl::
  post_ValueLabelEntry ()
  {
    const ::std::string& v (post_string ());

    m_value.assign(v);

    return m_value;
  }

  // UnityIdEntry_pimpl
  //

  void UnityIdEntry_pimpl::
  pre ()
  {
    m_value = 0;
  }

  rtap_db_dict::id_t UnityIdEntry_pimpl::
  post_UnityIdEntry ()
  {
    long long v (post_integer ());

    if ((0 <= v) && (v <= UNITY_ENTRY_MAX))
      m_value = static_cast<rtap_db_dict::id_t>(v);

    return m_value;
  }

  // UnityDimensionType_pimpl
  //

  void UnityDimensionType_pimpl::
  pre ()
  {
    m_value = 0;
  }

  rtap_db_dict::id_t UnityDimensionType_pimpl::
  post_UnityDimensionType ()
  {
    long long v (post_integer ());

    if ((0 <= v) && (v <= DIMENSION_ENTRY_MAX))
      m_value = static_cast<rtap_db_dict::id_t>(v);

    return m_value;
  }

  // UnityDimensionEntry_pimpl
  //

  void UnityDimensionEntry_pimpl::
  pre ()
  {
  }

  rtap_db_dict::Label_t& UnityDimensionEntry_pimpl::
  post_UnityDimensionEntry ()
  {
    const ::std::string& v (post_string ());

    m_value.assign(v);

    return m_value;
  }

  // UnityIdType_pimpl
  //

  void UnityIdType_pimpl::
  pre ()
  {
    m_value = 0;
  }

  rtap_db_dict::id_t UnityIdType_pimpl::
  post_UnityIdType ()
  {
    long long v (post_integer ());

    if ((0 <= v) && (v <= UNITY_TYPE_MAX))
      m_value = static_cast<rtap_db_dict::id_t>(v);

    return m_value;
  }

  // UnityLabelEntry_pimpl
  //

  void UnityLabelEntry_pimpl::
  pre ()
  {
  }

  rtap_db_dict::Label_t& UnityLabelEntry_pimpl::
  post_UnityLabelEntry ()
  {
    const ::std::string& v (post_string ());

    m_value.assign(v);

    return m_value;
  }

  // UnityDesignationEntry_pimpl
  //

  void UnityDesignationEntry_pimpl::
  pre ()
  {
  }

  rtap_db_dict::Label_t& UnityDesignationEntry_pimpl::
  post_UnityDesignationEntry ()
  {
    const ::std::string& v (post_string ());

    m_value.assign(v);

    return m_value;
  }

  // InfoTypeEntry_pimpl
  //

  void InfoTypeEntry_pimpl::
  pre ()
  {
  }

  rtap_db_dict::Label_t& InfoTypeEntry_pimpl::
  post_InfoTypeEntry ()
  {
    const ::std::string& v (post_string ());

    m_value.assign(v);

    return m_value;
  }

  // Dictionaries_pimpl
  //

  void Dictionaries_pimpl::
  pre ()
  {
    std::cout << "pre_Dictionaries" << std::endl;
  }

  void Dictionaries_pimpl::
  UNITY_LABEL ()
  {
#ifdef VERBOSE
    std::cout << "Push new UNITY_LABEL" << std::endl;
#endif
    dict.unity_dict.push_back(unity_label_item->Data());
  }

  void Dictionaries_pimpl::
  VAL_LABEL ()
  {
#ifdef VERBOSE
    std::cout << "Push new VAL_LABEL" << std::endl;
#endif
    dict.values_dict.push_back(value_label_item->Data());
  }

  void Dictionaries_pimpl::
  INFO_TYPES ()
  {
#ifdef VERBOSE
    std::cout << "Push new INFO_TYPE" << std::endl;
#endif
    dict.infotypes_dict.push_back(infotype_item->Data());
  }

  void Dictionaries_pimpl::
  post_Dictionaries ()
  {
#ifdef VERBOSE
    std::cout << "post_Dictionaries("
        << "unity: " << dict.unity_dict.size() << ", "
        << "value: " << dict.values_dict.size() << ", "
        << "infotypes: " << dict.infotypes_dict.size() << ")"
        << std::endl;
#endif
  }


  // UNITY_LABEL_pimpl
  //

  void UNITY_LABEL_pimpl::
  pre ()
  {
    unity_label_item = this;
  }

  void UNITY_LABEL_pimpl::
  UnityDimensionId (const rtap_db_dict::id_t& UnityDimensionId)
  {
    m_data.dimension_id = UnityDimensionId;
  }

  void UNITY_LABEL_pimpl::
  UnityDimension (rtap_db_dict::Label_t& UnityDimension)
  {
    m_data.dimension_entry.assign(UnityDimension);
  }

  void UNITY_LABEL_pimpl::
  UnityId (const rtap_db_dict::id_t& UnityId)
  {
    m_data.unity_id = UnityId;
  }

  void UNITY_LABEL_pimpl::
  UnityLabel (rtap_db_dict::Label_t& UnityLabel)
  {
    m_data.unity_entry.assign(UnityLabel);
  }

  void UNITY_LABEL_pimpl::
  UnityDesignation (rtap_db_dict::Label_t& UnityDesignation)
  {
    m_data.designation_entry.assign(UnityDesignation);
  }

  void UNITY_LABEL_pimpl::
  post_UNITY_LABEL ()
  {
#ifdef VERBOSE
    std::cout << "post_UNITY_LABEL: "
        << m_data.dimension_id << ":"
        << m_data.dimension_entry << ":"
        << m_data.unity_id << ":"
        << m_data.unity_entry << ":"
        << m_data.designation_entry
        << std::endl;
#endif
  }

  // VAL_LABEL_pimpl
  //

  void VAL_LABEL_pimpl::
  pre ()
  {
    value_label_item = this;
  }

  void VAL_LABEL_pimpl::
  ObjClass (const rtap_db_dict::ObjClass_t& ObjClass)
  {
    m_data.objclass = ObjClass;
  }

  void VAL_LABEL_pimpl::
  Val (const rtap_db_dict::id_t& Val)
  {
    m_data.value = Val;
  }

  void VAL_LABEL_pimpl::
  ValueLabel (rtap_db_dict::Label_t& ValueLabel)
  {
    m_data.label.assign(ValueLabel);
  }

  void VAL_LABEL_pimpl::
  post_VAL_LABEL ()
  {
#ifdef VERBOSE
    std::cout << "post_VAL_LABEL: "
        << m_data.objclass << ":"
        << m_data.value << ":"
        << m_data.label
        << std::endl;
#endif
  }

  // INFO_TYPES_pimpl
  //

  void INFO_TYPES_pimpl::
  pre ()
  {
    infotype_item = this;
  }

  void INFO_TYPES_pimpl::
  ObjClass (const rtap_db_dict::ObjClass_t& ObjClass)
  {
    m_data.objclass = ObjClass;
  }

  void INFO_TYPES_pimpl::
  IntoType (rtap_db_dict::Label_t& IntoType)
  {
    m_data.label.assign(IntoType);
  }

  void INFO_TYPES_pimpl::
  InfoTypeDesignation (const ::std::string& InfoTypeDesignation)
  {
    m_data.designation.assign(InfoTypeDesignation);
  }

  void INFO_TYPES_pimpl::
  post_INFO_TYPES ()
  {
#ifdef VERBOSE
    std::cout << "post_INFO_TYPES: "
        << m_data.objclass << ":"
        << m_data.label << ":"
        << m_data.designation
        << std::endl;
#endif
  }
}

